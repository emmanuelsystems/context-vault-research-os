import express from "express";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

const server = new McpServer({
    name: "Context Vault + Research OS",
    version: "1.0.0",
});

import cors from "cors";

const app = express();
app.use(cors()); // Allow all origins for MCP
app.use(express.json());


import { z } from "zod";
import { RunManager } from "../context-vault/api/run-manager.js";
import { ArtifactManager } from "../context-vault/api/artifact-manager.js";
import { FileRunManager } from "../context-vault/storage/file-run-manager.js";
import { ContextManager } from "../context-vault/api/context-manager.js";
import { prisma } from "../context-vault/client.js";
import { Catalog } from "../research-os/catalog.js";
import { put } from "@vercel/blob";

// --- Tools ---

// 1. Init Run
server.tool(
    "init_run",
    {
        domain: z.string().describe("Domain of research (e.g. infra, policy)"),
        title: z.string().describe("Title of the run"),
        question: z.string().describe("Primary research question"),
    },
    async ({ domain, title, question }) => {
        const year = new Date().getFullYear();
        const suffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        const runId = `RUN-${domain.toUpperCase()}-${year}-${suffix}`;

        const run = await RunManager.createRun({
            run_id: runId,
            title,
            primary_question: question,
            domain,
            owner_user_id: "MCP-Agent",
        });

        return {
            content: [{ type: "text", text: `Run Initialized: ${run.id} (${run.status})` }],
        };
    }
);

// 2. Create Handshake
server.tool(
    "create_handshake",
    {
        run_id: z.string(),
        decision_type: z.enum(['choose', 'learn', 'verify', 'compare']),
        notes: z.string().optional(),
    },
    async ({ run_id, decision_type, notes }) => {
        const run = await RunManager.getRun(run_id);
        if (!run) throw new Error(`Run ${run_id} not found`);

        const payload = {
            run_id,
            decision_type,
            notes: notes || "Created via MCP",
            status: "Draft", // Logic can be enhanced
        };

        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'HS',
            payload,
            status: 'Approved' // Speedrun mode
        });

        return {
            content: [{ type: "text", text: `Handshake Created: ${artifact.id} (Approved)` }],
        };
    }
);

// 3. Generate Path Map
server.tool(
    "generate_pathmap",
    { run_id: z.string() },
    async ({ run_id }) => {
        const run = await RunManager.getRun(run_id);
        if (!run) throw new Error(`Run not found`);

        const hs = (await ArtifactManager.listArtifacts(run_id, 'HS')).pop();
        if (!hs) throw new Error("No Handshake found");

        const decisionType = JSON.parse(hs.payload).decision_type;
        const engines = Catalog.getEnginesByFamily(decisionType);

        const rows = engines.map(e => ({
            path_name: `Path via ${e.name}`,
            engine: e.id,
            container: e.default_containers[0] || 'generic'
        }));

        if (rows.length === 0) rows.push({ path_name: "Default Path", engine: "custom", container: "generic" });

        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'PM',
            payload: { rows },
            status: 'Draft'
        });

        return {
            content: [{ type: "text", text: `Path Map Generated: ${artifact.id} with ${rows.length} paths` }],
        };
    }
);

// 4. Create Charter
server.tool(
    "create_charter",
    { run_id: z.string() },
    async ({ run_id }) => {
        // Simplistic charter logic
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'CH',
            payload: { note: "Charter auto-generated by MCP" },
            status: 'Approved'
        });
        return {
            content: [{ type: "text", text: `Charter Created: ${artifact.id} (Approved)` }],
        };
    }
);

// 5. Output
server.tool(
    "add_output",
    {
        run_id: z.string(),
        engine_id: z.string(),
        container_id: z.string(),
        content: z.string()
    },
    async ({ run_id, engine_id, container_id, content }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'OUTPUT',
            engine: engine_id,
            container: container_id,
            payload: { content },
            status: 'Final'
        });
        return {
            content: [{ type: "text", text: `Output Added: ${artifact.id}` }],
        };
    }
);

// 6. Retrieval Log
server.tool(
    "add_retrieval_log",
    { run_id: z.string(), source_url: z.string() },
    async ({ run_id, source_url }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'RL',
            payload: { sources: [{ url: source_url }] },
            status: 'Final'
        });
        return {
            content: [{ type: "text", text: `Retrieval Log Added: ${artifact.id}` }],
        };
    }
);

// 7. Decision
server.tool(
    "create_decision",
    { run_id: z.string(), decision: z.string() },
    async ({ run_id, decision }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'DT',
            payload: { decision },
            status: 'Final'
        });
        await RunManager.updateStatus(run_id, 'ReadyForBanking', 'MCP');
        return {
            content: [{ type: "text", text: `Decision Trace Created: ${artifact.id}` }],
        };
    }
);

// 8. Bank Run
server.tool(
    "bank_run",
    { run_id: z.string() },
    async ({ run_id }) => {
        const result = await RunManager.bankRun(run_id, 'MCP-System');
        if (result.success) {
            return { content: [{ type: "text", text: `Run Banked Successfully!` }] };
        } else {
            return {
                isError: true,
                content: [{ type: "text", text: `Banking Failed. Missing: ${(result.missing || []).join(', ')}` }]
            };
        }
    }
);


// --- Resources ---

server.resource(
    "engines",
    "research://catalog/engines",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: JSON.stringify(Catalog.getEngines(), null, 2),
            mimeType: "application/json"
        }]
    })
);

server.resource(
    "containers",
    "research://catalog/containers",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: JSON.stringify(Catalog.getContainers(), null, 2),
            mimeType: "application/json"
        }]
    })
);

server.resource(
    "active_runs",
    "research://runs/active",
    async (uri) => {
        const runs = await RunManager.listRuns('Draft');
        return {
            contents: [{
                uri: uri.href,
                text: JSON.stringify(runs, null, 2),
                mimeType: "application/json"
            }]
        };
    }
);


// --- UI API Endpoints ---

app.get("/api/runs", async (req, res) => {
    try {
        const runs = await RunManager.listRuns();
        if (runs.length === 0) {
            const fileRuns = await FileRunManager.listRuns();
            res.json(fileRuns);
            return;
        }
        res.json(runs);
    } catch (e) {
        try {
            const fileRuns = await FileRunManager.listRuns();
            res.json(fileRuns);
        } catch {
            res.status(500).json({ error: "Failed to list runs" });
        }
    }
});

app.get("/api/runs/:id", async (req, res) => {
    try {
        const run = await RunManager.getRun(req.params.id);
        if (run) {
            const artifacts = await ArtifactManager.listArtifacts(req.params.id);
            const context_links = await prisma.runContextLink.findMany({
                where: { run_id: req.params.id },
                include: { context_item: true },
                orderBy: { created_at: 'desc' }
            }).catch(() => [] as any[]);

            res.json({
                ...run,
                artifacts,
                receipts: (run as any).receipts || [],
                context_items: context_links.map(l => l.context_item)
            });
            return;
        }

        const fileRun = await FileRunManager.getRun(req.params.id);
        if (!fileRun) {
            res.status(404).json({ error: "Run not found" });
            return;
        }
        res.json(fileRun);
    } catch (e) {
        try {
            const fileRun = await FileRunManager.getRun(req.params.id);
            if (!fileRun) {
                res.status(404).json({ error: "Run not found" });
                return;
            }
            res.json(fileRun);
        } catch {
            res.status(500).json({ error: "Failed to get run" });
        }
    }
});

// Raw file uploads to Vercel Blob (Memory captures)
app.put("/api/upload", express.raw({ type: "*/*", limit: "25mb" }), async (req, res) => {
    try {
        const filename = (req.query.filename?.toString() || "memory-capture").replace(/[^\w.\-]+/g, "_");
        const contentType = req.headers["content-type"]?.toString() || "application/octet-stream";

        if (!Buffer.isBuffer(req.body)) {
            res.status(400).json({ error: "Expected binary body" });
            return;
        }

        const blob = await put(`context/${Date.now()}-${filename}`, req.body, {
            access: "public",
            contentType,
        });

        res.json({ url: blob.url });
    } catch (e: any) {
        res.status(500).json({ error: "Failed to upload", message: e?.message });
    }
});

// --- Context Memory (Phase 1) ---

app.post("/api/context-items", async (req, res) => {
    try {
        const body = req.body || {};
        const item = await ContextManager.createContextItem({
            layer: body.layer || 'RAW',
            source_type: body.source_type,
            title: body.title,
            project: body.project,
            people: Array.isArray(body.people) ? body.people : undefined,
            topics: Array.isArray(body.topics) ? body.topics : undefined,
            occurred_at: body.occurred_at,
            content_text: body.content_text,
            content_ref: body.content_ref,
            payload: body.payload,
            created_by: body.created_by,
        });
        res.json(item);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to create context item", message: e?.message });
    }
});

app.get("/api/context-items", async (req, res) => {
    try {
        const items = await ContextManager.listContextItems({
            q: req.query.q?.toString(),
            layer: req.query.layer?.toString(),
            project: req.query.project?.toString(),
            from: req.query.from?.toString(),
            to: req.query.to?.toString(),
        });
        res.json(items);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to list context items", message: e?.message });
    }
});

app.get("/api/context-items/:id", async (req, res) => {
    try {
        const item = await ContextManager.getContextItem(req.params.id);
        if (!item) {
            res.status(404).json({ error: "Context item not found" });
            return;
        }
        res.json(item);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to get context item", message: e?.message });
    }
});

app.post("/api/runs/:id/context-links", async (req, res) => {
    try {
        const context_item_id = req.body?.context_item_id;
        if (!context_item_id) {
            res.status(400).json({ error: "context_item_id is required" });
            return;
        }
        const link = await ContextManager.linkContextToRun({
            run_id: req.params.id,
            context_item_id,
        });
        res.json(link);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to link context item", message: e?.message });
    }
});


app.get("/api/debug", (req, res) => {
    res.json({
        status: "ok",
        env: {
            has_db_url: !!process.env.DATABASE_URL,
            db_url_start: process.env.DATABASE_URL ? process.env.DATABASE_URL.substring(0, 10) : "N/A",
            node_env: process.env.NODE_ENV
        }
    });
});

const transports = new Map<string, SSEServerTransport>();

app.get("/sse", async (req, res) => {
    console.log("New SSE Connection");

    // Create a unique session ID for this connection
    const sessionId = Math.random().toString(36).substring(7);

    // Build an absolute message URL so clients (incl. ChatGPT Apps) don't have to resolve a relative path.
    const hostHeader = (req.headers['x-forwarded-host'] || req.headers.host || '').toString();
    const proto = (req.headers['x-forwarded-proto'] || 'https').toString();
    const baseFromHeaders = hostHeader ? `${proto}://${hostHeader}` : undefined;
    const base = process.env.MCP_BASE_URL || baseFromHeaders || 'https://context-vault-research-os.vercel.app';
    const messagePath = `/api/message?sessionId=${sessionId}`;
    const messageUrl = `${base}${messagePath}`;

    const transport = new SSEServerTransport(messageUrl, res);

    transports.set(sessionId, transport);

    transport.onclose = () => {
        console.log(`SSE Connection closed: ${sessionId}`);
        transports.delete(sessionId);
    };

    await server.connect(transport);
});

app.post("/api/message", async (req, res) => {
    const sessionId = req.query.sessionId as string;
    const transport = transports.get(sessionId);

    if (!transport) {
        console.log(`Session not found: ${sessionId}`);
        res.status(404).send("Session not found");
        return;
    }

    // Delegate the message handling to the transport
    await transport.handlePostMessage(req, res);
});

// Global Error Handler to prevent crashes
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
    console.error("Unhandled Server Error:", err);
    if (res.headersSent) {
        return next(err);
    }
    res.status(500).json({
        error: "Internal Server Error",
        message: err.message || "Unknown error",
        stack: process.env.NODE_ENV === 'production' ? undefined : err.stack
    });
});

// Export app for Vercel (must be default export)
export default app;

// If you need to run this locally, use a separate entry point (e.g. dev-server.ts)
// or rely on the `tsx` command in package.json which runs the CLI.


