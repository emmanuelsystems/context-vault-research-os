import express from "express";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";

const server = new McpServer({
    name: "Context Vault + Research OS",
    version: "1.0.0",
});

import cors from "cors";

const app = express();
app.use(cors()); // Allow all origins for MCP
app.use(express.json());


import { z } from "zod";
import { RunManager } from "../context-vault/api/run-manager.js";
import { ArtifactManager } from "../context-vault/api/artifact-manager.js";
import { ReceiptManager } from "../context-vault/api/receipt-manager.js";
import { FileRunManager } from "../context-vault/storage/file-run-manager.js";
import { ContextManager } from "../context-vault/api/context-manager.js";
import { prisma } from "../context-vault/client.js";
import { Catalog } from "../research-os/catalog.js";
import { PromptLibrary } from "../research-os/prompt-library.js";
import { put } from "@vercel/blob";

// --- Tools ---

// 1. Init Run
server.tool(
    "init_run",
    {
        domain: z.string().describe("Domain of research (e.g. infra, policy)"),
        title: z.string().describe("Title of the run"),
        question: z.string().describe("Primary research question"),
    },
    async ({ domain, title, question }) => {
        const year = new Date().getFullYear();
        const suffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        const runId = `RUN-${domain.toUpperCase()}-${year}-${suffix}`;

        const run = await RunManager.createRun({
            run_id: runId,
            title,
            primary_question: question,
            domain,
            owner_user_id: "MCP-Agent",
        });

        return {
            content: [{ type: "text", text: `Run Initialized: ${run.id} (${run.status})` }],
        };
    }
);

// 2. Create Handshake
server.tool(
    "create_handshake",
    {
        run_id: z.string(),
        decision_type: z.enum(['choose', 'learn', 'verify', 'compare']),
        notes: z.string().optional(),
    },
    async ({ run_id, decision_type, notes }) => {
        const run = await RunManager.getRun(run_id);
        if (!run) throw new Error(`Run ${run_id} not found`);

        const payload = {
            run_id,
            decision_type,
            notes: notes || "Created via MCP",
            status: "Draft", // Logic can be enhanced
        };

        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'HS',
            payload,
            status: 'Approved' // Speedrun mode
        });

        return {
            content: [{ type: "text", text: `Handshake Created: ${artifact.id} (Approved)` }],
        };
    }
);

// 3. Generate Path Map
server.tool(
    "generate_pathmap",
    { run_id: z.string() },
    async ({ run_id }) => {
        const run = await RunManager.getRun(run_id);
        if (!run) throw new Error(`Run not found`);

        const hs = (await ArtifactManager.listArtifacts(run_id, 'HS')).pop();
        if (!hs) throw new Error("No Handshake found");

        const decisionType = JSON.parse(hs.payload).decision_type;
        const engines = Catalog.getEnginesByFamily(decisionType);

        const rows = engines.map(e => ({
            path_name: `Path via ${e.name}`,
            engine: e.id,
            container: e.default_containers[0] || 'generic'
        }));

        if (rows.length === 0) rows.push({ path_name: "Default Path", engine: "custom", container: "generic" });

        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'PM',
            payload: { rows },
            status: 'Draft'
        });

        return {
            content: [{ type: "text", text: `Path Map Generated: ${artifact.id} with ${rows.length} paths` }],
        };
    }
);

// 4. Create Charter
server.tool(
    "create_charter",
    { run_id: z.string() },
    async ({ run_id }) => {
        // Simplistic charter logic
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'CH',
            payload: { note: "Charter auto-generated by MCP" },
            status: 'Approved'
        });
        return {
            content: [{ type: "text", text: `Charter Created: ${artifact.id} (Approved)` }],
        };
    }
);

// 5. Output
server.tool(
    "add_output",
    {
        run_id: z.string(),
        engine_id: z.string(),
        container_id: z.string(),
        content: z.string()
    },
    async ({ run_id, engine_id, container_id, content }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'OUTPUT',
            engine: engine_id,
            container: container_id,
            payload: { content },
            status: 'Final'
        });
        return {
            content: [{ type: "text", text: `Output Added: ${artifact.id}` }],
        };
    }
);

// 6. Retrieval Log
server.tool(
    "add_retrieval_log",
    { run_id: z.string(), source_url: z.string() },
    async ({ run_id, source_url }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'RL',
            payload: { sources: [{ url: source_url }] },
            status: 'Final'
        });
        return {
            content: [{ type: "text", text: `Retrieval Log Added: ${artifact.id}` }],
        };
    }
);

// 7. Decision
server.tool(
    "create_decision",
    { run_id: z.string(), decision: z.string() },
    async ({ run_id, decision }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'DT',
            payload: { decision },
            status: 'Final'
        });
        await RunManager.updateStatus(run_id, 'ReadyForBanking', 'MCP');
        return {
            content: [{ type: "text", text: `Decision Trace Created: ${artifact.id}` }],
        };
    }
);

// 8. Bank Run
server.tool(
    "bank_run",
    { run_id: z.string() },
    async ({ run_id }) => {
        const result = await RunManager.bankRun(run_id, 'MCP-System');
        if (result.success) {
            return { content: [{ type: "text", text: `Run Banked Successfully!` }] };
        } else {
            return {
                isError: true,
                content: [{ type: "text", text: `Banking Failed. Missing: ${(result.missing || []).join(', ')}` }]
            };
        }
    }
);

// 9. Memory Capture (Context Vault)
server.tool(
    "capture_context_item",
    {
        layer: z.enum(['RAW', 'SENSEMAKING', 'STRUCTURED', 'APPLICATION']).default('RAW'),
        title: z.string().optional(),
        project: z.string().optional(),
        source_type: z.string().optional(),
        occurred_at: z.string().optional().describe("ISO datetime, e.g. 2026-01-20T12:34:56Z"),
        people: z.array(z.string()).optional(),
        topics: z.array(z.string()).optional(),
        content_text: z.string().optional(),
        content_ref: z.string().optional(),
        payload: z.any().optional(),
        run_id: z.string().optional().describe("If provided, link this context item to the run"),
        created_by: z.string().optional(),
    },
    async (input) => {
        const item = await ContextManager.createContextItem({
            layer: input.layer,
            source_type: input.source_type,
            title: input.title,
            project: input.project,
            people: input.people,
            topics: input.topics,
            occurred_at: input.occurred_at,
            content_text: input.content_text,
            content_ref: input.content_ref,
            payload: input.payload,
            created_by: input.created_by || 'MCP-Agent',
        });

        if (input.run_id) {
            await ContextManager.linkContextToRun({
                run_id: input.run_id,
                context_item_id: item.id,
            });
        }

        return {
            content: [{
                type: "text",
                text: input.run_id
                    ? `Context Item Captured: ${item.id} (linked to ${input.run_id})`
                    : `Context Item Captured: ${item.id}`
            }],
        };
    }
);


// --- Resources ---

server.resource(
    "engines",
    "research://catalog/engines",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: JSON.stringify(Catalog.getEngines(), null, 2),
            mimeType: "application/json"
        }]
    })
);

server.resource(
    "containers",
    "research://catalog/containers",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: JSON.stringify(Catalog.getContainers(), null, 2),
            mimeType: "application/json"
        }]
    })
);

server.resource(
    "active_runs",
    "research://runs/active",
    async (uri) => {
        const runs = await RunManager.listRuns('Draft');
        return {
            contents: [{
                uri: uri.href,
                text: JSON.stringify(runs, null, 2),
                mimeType: "application/json"
            }]
        };
    }
);

server.resource(
    "prompts_index",
    "research://prompts",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: JSON.stringify(PromptLibrary.list(), null, 2),
            mimeType: "application/json"
        }]
    })
);

server.resource(
    "handshake_prompt_pathmap_v1",
    "research://prompts/handshake/pathmap-v1",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: PromptLibrary.get('handshake.pathmap.v1'),
            mimeType: "text/markdown"
        }]
    })
);

server.resource(
    "research_charter_template_v1",
    "research://prompts/charter/v1",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: PromptLibrary.get('charter.v1'),
            mimeType: "text/markdown"
        }]
    })
);

server.resource(
    "deep_research_prompt_builder_v1",
    "research://prompts/deep-research/prompt-builder-v1",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: PromptLibrary.get('deep-research.prompt-builder.v1'),
            mimeType: "text/markdown"
        }]
    })
);


// --- MCP Transport (recommended for serverless) ---
// Streamable HTTP is designed to work without a separate /message endpoint and avoids session stickiness issues.
// Important: define all tools/resources BEFORE connecting, otherwise MCP SDK will throw.
const mcpHttpTransport = new StreamableHTTPServerTransport({
    // Stateless mode: no session persistence required (best fit for Vercel serverless).
    sessionIdGenerator: undefined,
});
void server.connect(mcpHttpTransport).catch((e) => {
    console.error("Failed to connect MCP Streamable HTTP transport", e);
});
app.all("/api/mcp", async (req, res) => {
    await mcpHttpTransport.handleRequest(req, res, (req as any).body);
});


// --- UI API Endpoints ---

app.get("/api/runs", async (req, res) => {
    try {
        const runs = await RunManager.listRuns();
        if (runs.length === 0) {
            const fileRuns = await FileRunManager.listRuns();
            res.json(fileRuns);
            return;
        }
        res.json(runs);
    } catch (e) {
        try {
            const fileRuns = await FileRunManager.listRuns();
            res.json(fileRuns);
        } catch {
            res.status(500).json({ error: "Failed to list runs" });
        }
    }
});

app.post("/api/runs", async (req, res) => {
    try {
        const body = req.body || {};
        const domain = (body.domain || '').toString().trim();
        const title = (body.title || '').toString().trim();
        const primary_question = (body.primary_question || body.question || '').toString().trim();
        const rawStake = (body.stake_level || '').toString().trim().toLowerCase();
        const stake_level = (rawStake === 'low' || rawStake === 'medium' || rawStake === 'high') ? rawStake : undefined;
        const requestedId = (body.run_id || body.id || '').toString().trim();

        if (!domain || !title || !primary_question) {
            res.status(400).json({ error: "domain, title, and primary_question are required" });
            return;
        }

        const year = new Date().getFullYear();
        const suffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        const runId = requestedId || `RUN-${domain.toUpperCase()}-${year}-${suffix}`;

        const run = await RunManager.createRun({
            run_id: runId,
            title,
            primary_question,
            domain,
            stake_level,
            owner_user_id: "WEB",
        });

        res.json(run);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to create run", message: e?.message });
    }
});

app.post("/api/runs/:id/handshake", async (req, res) => {
    try {
        const run_id = req.params.id;
        const run = await RunManager.getRun(run_id);
        if (!run) {
            res.status(404).json({ error: "Run not found" });
            return;
        }

        const body = req.body || {};
        const decision_type = (body.decision_type || '').toString().trim().toLowerCase();
        const notes = (body.notes || '').toString().trim();
        const unknowns = Array.isArray(body.unknowns)
            ? body.unknowns.map((u: any) => (u ?? '').toString().trim()).filter(Boolean)
            : [];
        const assumptions = Array.isArray(body.assumptions)
            ? body.assumptions.map((a: any) => (a ?? '').toString().trim()).filter(Boolean)
            : [];
        const assumption_tests = Array.isArray(body.assumption_tests)
            ? body.assumption_tests.map((a: any) => (a ?? '').toString().trim()).filter(Boolean)
            : [];

        if (!['choose', 'learn', 'verify', 'compare'].includes(decision_type)) {
            res.status(400).json({ error: "decision_type must be one of choose|learn|verify|compare" });
            return;
        }

        const payload = {
            run_id,
            primary_question: (run as any).primary_question,
            decision_type,
            notes: notes || undefined,
            unknowns,
            assumptions,
            assumption_tests,
            status: "Approved",
        };

        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'HS',
            payload,
            status: 'Approved',
        });

        const receipt = await ReceiptManager.upsertReceipt({
            run_id,
            commit_point: 'HS_LOCKED',
            summary: 'Handshake locked',
            inputs: [{ type: 'artifact_id', id: artifact.id }],
            constraints: [`decision_type=${decision_type}`],
            decision_makers: ['WEB'],
            outcome: `primary_question locked; decision_type=${decision_type}`,
            approvals: [{ name: 'WEB', role: 'Approver', approved_at: new Date().toISOString() }],
        });

        res.json({ artifact, receipt });
    } catch (e: any) {
        res.status(500).json({ error: "Failed to create handshake", message: e?.message });
    }
});

app.get("/api/runs/:id", async (req, res) => {
    try {
        const run = await RunManager.getRun(req.params.id);
        if (run) {
            const artifacts = await ArtifactManager.listArtifacts(req.params.id);
            const context_links = await prisma.runContextLink.findMany({
                where: { run_id: req.params.id },
                include: { context_item: true },
                orderBy: { created_at: 'desc' }
            }).catch(() => [] as any[]);

            res.json({
                ...run,
                artifacts,
                receipts: (run as any).receipts || [],
                context_items: context_links.map(l => l.context_item)
            });
            return;
        }

        const fileRun = await FileRunManager.getRun(req.params.id);
        if (!fileRun) {
            res.status(404).json({ error: "Run not found" });
            return;
        }
        res.json(fileRun);
    } catch (e) {
        try {
            const fileRun = await FileRunManager.getRun(req.params.id);
            if (!fileRun) {
                res.status(404).json({ error: "Run not found" });
                return;
            }
            res.json(fileRun);
        } catch {
            res.status(500).json({ error: "Failed to get run" });
        }
    }
});

// Raw file uploads to Vercel Blob (Memory captures)
app.put("/api/upload", express.raw({ type: "*/*", limit: "25mb" }), async (req, res) => {
    try {
        const filename = (req.query.filename?.toString() || "memory-capture").replace(/[^\w.\-]+/g, "_");
        const contentType = req.headers["content-type"]?.toString() || "application/octet-stream";

        if (!Buffer.isBuffer(req.body)) {
            res.status(400).json({ error: "Expected binary body" });
            return;
        }

        const blob = await put(`context/${Date.now()}-${filename}`, req.body, {
            access: "public",
            contentType,
        });

        res.json({ url: blob.url });
    } catch (e: any) {
        res.status(500).json({ error: "Failed to upload", message: e?.message });
    }
});

// --- Context Memory (Phase 1) ---

app.post("/api/context-items", async (req, res) => {
    try {
        const body = req.body || {};
        const item = await ContextManager.createContextItem({
            layer: body.layer || 'RAW',
            source_type: body.source_type,
            title: body.title,
            project: body.project,
            people: Array.isArray(body.people) ? body.people : undefined,
            topics: Array.isArray(body.topics) ? body.topics : undefined,
            occurred_at: body.occurred_at,
            content_text: body.content_text,
            content_ref: body.content_ref,
            payload: body.payload,
            created_by: body.created_by,
        });
        res.json(item);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to create context item", message: e?.message });
    }
});

app.get("/api/context-items", async (req, res) => {
    try {
        const items = await ContextManager.listContextItems({
            q: req.query.q?.toString(),
            layer: req.query.layer?.toString(),
            project: req.query.project?.toString(),
            from: req.query.from?.toString(),
            to: req.query.to?.toString(),
        });
        res.json(items);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to list context items", message: e?.message });
    }
});

app.get("/api/context-items/:id", async (req, res) => {
    try {
        const item = await ContextManager.getContextItem(req.params.id);
        if (!item) {
            res.status(404).json({ error: "Context item not found" });
            return;
        }
        res.json(item);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to get context item", message: e?.message });
    }
});

app.post("/api/runs/:id/context-links", async (req, res) => {
    try {
        const context_item_id = req.body?.context_item_id;
        if (!context_item_id) {
            res.status(400).json({ error: "context_item_id is required" });
            return;
        }
        const link = await ContextManager.linkContextToRun({
            run_id: req.params.id,
            context_item_id,
        });
        res.json(link);
    } catch (e: any) {
        res.status(500).json({ error: "Failed to link context item", message: e?.message });
    }
});


app.get("/api/debug", (req, res) => {
    res.json({
        status: "ok",
        env: {
            has_db_url: !!process.env.DATABASE_URL,
            db_url_start: process.env.DATABASE_URL ? process.env.DATABASE_URL.substring(0, 10) : "N/A",
            node_env: process.env.NODE_ENV
        }
    });
});

// NOTE: SSE transport requires session stickiness between GET /sse and POST /api/message.
// On Vercel serverless, these often land on different invocations, so sessions can't be found.
// Keep this path for local/dev debugging, but prefer /api/mcp for ChatGPT connectors.
const transports = new Map<string, SSEServerTransport>();

const handleSse = async (req: express.Request, res: express.Response) => {
    console.log("New SSE Connection", {
        method: req.method,
        path: req.path,
    });

    // Allow cross-origin usage for MCP clients (ChatGPT connector, etc.)
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'content-type, authorization');
    res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
    res.setHeader('Cache-Control', 'no-cache, no-transform');
    res.setHeader('X-Accel-Buffering', 'no');

    // Create a unique session ID for this connection
    const sessionId = Math.random().toString(36).substring(7);

    // Build an absolute message URL so clients (incl. ChatGPT Apps) don't have to resolve a relative path.
    const hostHeader = (req.headers['x-forwarded-host'] || req.headers.host || '').toString();
    const proto = (req.headers['x-forwarded-proto'] || 'https').toString();
    const baseFromHeaders = hostHeader ? `${proto}://${hostHeader}` : undefined;
    const base = process.env.MCP_BASE_URL || baseFromHeaders || 'https://context-vault-research-os.vercel.app';
    const messagePath = `/api/message?sessionId=${sessionId}`;
    const messageUrl = `${base}${messagePath}`;

    const transport = new SSEServerTransport(messageUrl, res);

    transports.set(sessionId, transport);

    transport.onclose = () => {
        console.log(`SSE Connection closed: ${sessionId}`);
        transports.delete(sessionId);
    };

    // Don't await: in serverless environments, awaiting a never-resolving promise can trigger timeouts.
    void server.connect(transport).catch((e: any) => {
        console.error('Failed to start MCP SSE transport', e);
        try {
            res.end();
        } catch {
            // ignore
        }
    });
};

// Prefer /api/sse for deployments behind static frontends.
app.get("/api/sse", handleSse);
// Backwards compat: /sse (rewritten to /api/index on Vercel).
app.get("/sse", handleSse);

app.options("/api/sse", (_req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'content-type, authorization');
    res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
    res.status(204).end();
});
app.options("/sse", (_req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'content-type, authorization');
    res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
    res.status(204).end();
});

// Some clients probe the MCP URL with POST; make it explicit this endpoint is GET-only.
app.post("/api/sse", (_req, res) => res.status(405).send("MCP SSE endpoint: use GET"));
app.post("/sse", (_req, res) => res.status(405).send("MCP SSE endpoint: use GET"));

app.post("/api/message", async (req, res) => {
    const sessionId = req.query.sessionId as string;
    const transport = transports.get(sessionId);

    if (!transport) {
        console.log(`Session not found: ${sessionId}`);
        res.status(404).send("Session not found");
        return;
    }

    // Delegate the message handling to the transport
    await transport.handlePostMessage(req, res);
});

app.options("/api/message", (_req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'content-type, authorization');
    res.setHeader('Access-Control-Allow-Methods', 'POST,OPTIONS');
    res.status(204).end();
});

// Global Error Handler to prevent crashes
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
    console.error("Unhandled Server Error:", err);
    if (res.headersSent) {
        return next(err);
    }
    res.status(500).json({
        error: "Internal Server Error",
        message: err.message || "Unknown error",
        stack: process.env.NODE_ENV === 'production' ? undefined : err.stack
    });
});

// Export app for Vercel (must be default export)
export default app;

// If you need to run this locally, use a separate entry point (e.g. dev-server.ts)
// or rely on the `tsx` command in package.json which runs the CLI.


