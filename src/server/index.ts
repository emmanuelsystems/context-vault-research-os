import express from "express";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

const server = new McpServer({
    name: "Context Vault + Research OS",
    version: "1.0.0",
});

const app = express();


import { z } from "zod";
import { RunManager } from "../context-vault/api/run-manager.js";
import { ArtifactManager } from "../context-vault/api/artifact-manager.js";
import { Catalog } from "../research-os/catalog.js";

// --- Tools ---

// 1. Init Run
server.tool(
    "init_run",
    {
        domain: z.string().describe("Domain of research (e.g. infra, policy)"),
        title: z.string().describe("Title of the run"),
        question: z.string().describe("Primary research question"),
    },
    async ({ domain, title, question }) => {
        const year = new Date().getFullYear();
        const suffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        const runId = `RUN-${domain.toUpperCase()}-${year}-${suffix}`;

        const run = await RunManager.createRun({
            run_id: runId,
            title,
            primary_question: question,
            domain,
            owner_user_id: "MCP-Agent",
        });

        return {
            content: [{ type: "text", text: `Run Initialized: ${run.id} (${run.status})` }],
        };
    }
);

// 2. Create Handshake
server.tool(
    "create_handshake",
    {
        run_id: z.string(),
        decision_type: z.enum(['choose', 'learn', 'verify', 'compare']),
        notes: z.string().optional(),
    },
    async ({ run_id, decision_type, notes }) => {
        const run = await RunManager.getRun(run_id);
        if (!run) throw new Error(`Run ${run_id} not found`);

        const payload = {
            run_id,
            decision_type,
            notes: notes || "Created via MCP",
            status: "Draft", // Logic can be enhanced
        };

        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'HS',
            payload,
            status: 'Approved' // Speedrun mode
        });

        return {
            content: [{ type: "text", text: `Handshake Created: ${artifact.id} (Approved)` }],
        };
    }
);

// 3. Generate Path Map
server.tool(
    "generate_pathmap",
    { run_id: z.string() },
    async ({ run_id }) => {
        const run = await RunManager.getRun(run_id);
        if (!run) throw new Error(`Run not found`);

        const hs = (await ArtifactManager.listArtifacts(run_id, 'HS')).pop();
        if (!hs) throw new Error("No Handshake found");

        const decisionType = JSON.parse(hs.payload).decision_type;
        const engines = Catalog.getEnginesByFamily(decisionType);

        const rows = engines.map(e => ({
            path_name: `Path via ${e.name}`,
            engine: e.id,
            container: e.default_containers[0] || 'generic'
        }));

        if (rows.length === 0) rows.push({ path_name: "Default Path", engine: "custom", container: "generic" });

        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'PM',
            payload: { rows },
            status: 'Draft'
        });

        return {
            content: [{ type: "text", text: `Path Map Generated: ${artifact.id} with ${rows.length} paths` }],
        };
    }
);

// 4. Create Charter
server.tool(
    "create_charter",
    { run_id: z.string() },
    async ({ run_id }) => {
        // Simplistic charter logic
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'CH',
            payload: { note: "Charter auto-generated by MCP" },
            status: 'Approved'
        });
        return {
            content: [{ type: "text", text: `Charter Created: ${artifact.id} (Approved)` }],
        };
    }
);

// 5. Output
server.tool(
    "add_output",
    {
        run_id: z.string(),
        engine_id: z.string(),
        container_id: z.string(),
        content: z.string()
    },
    async ({ run_id, engine_id, container_id, content }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'OUTPUT',
            engine: engine_id,
            container: container_id,
            payload: { content },
            status: 'Final'
        });
        return {
            content: [{ type: "text", text: `Output Added: ${artifact.id}` }],
        };
    }
);

// 6. Retrieval Log
server.tool(
    "add_retrieval_log",
    { run_id: z.string(), source_url: z.string() },
    async ({ run_id, source_url }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'RL',
            payload: { sources: [{ url: source_url }] },
            status: 'Final'
        });
        return {
            content: [{ type: "text", text: `Retrieval Log Added: ${artifact.id}` }],
        };
    }
);

// 7. Decision
server.tool(
    "create_decision",
    { run_id: z.string(), decision: z.string() },
    async ({ run_id, decision }) => {
        const artifact = await ArtifactManager.addArtifact({
            run_id,
            artifact_type: 'DT',
            payload: { decision },
            status: 'Final'
        });
        await RunManager.updateStatus(run_id, 'ReadyForBanking', 'MCP');
        return {
            content: [{ type: "text", text: `Decision Trace Created: ${artifact.id}` }],
        };
    }
);

// 8. Bank Run
server.tool(
    "bank_run",
    { run_id: z.string() },
    async ({ run_id }) => {
        const result = await RunManager.bankRun(run_id, 'MCP-System');
        if (result.success) {
            return { content: [{ type: "text", text: `Run Banked Successfully!` }] };
        } else {
            return {
                isError: true,
                content: [{ type: "text", text: `Banking Failed. Missing: ${(result.missing || []).join(', ')}` }]
            };
        }
    }
);


// --- Resources ---

server.resource(
    "engines",
    "research://catalog/engines",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: JSON.stringify(Catalog.getEngines(), null, 2),
            mimeType: "application/json"
        }]
    })
);

server.resource(
    "containers",
    "research://catalog/containers",
    async (uri) => ({
        contents: [{
            uri: uri.href,
            text: JSON.stringify(Catalog.getContainers(), null, 2),
            mimeType: "application/json"
        }]
    })
);

server.resource(
    "active_runs",
    "research://runs/active",
    async (uri) => {
        const runs = await RunManager.listRuns('Draft');
        return {
            contents: [{
                uri: uri.href,
                text: JSON.stringify(runs, null, 2),
                mimeType: "application/json"
            }]
        };
    }
);


// --- UI API Endpoints ---

app.get("/runs", async (req, res) => {
    try {
        const runs = await RunManager.listRuns();
        res.json(runs);
    } catch (e) {
        res.status(500).json({ error: "Failed to list runs" });
    }
});

app.get("/runs/:id", async (req, res) => {
    try {
        const run = await RunManager.getRun(req.params.id);
        if (!run) {
            res.status(404).json({ error: "Run not found" });
            return;
        }
        const artifacts = await ArtifactManager.listArtifacts(req.params.id);
        res.json({ ...run, artifacts });
    } catch (e) {
        res.status(500).json({ error: "Failed to get run" });
    }
});


const transports = new Map<string, SSEServerTransport>();

app.get("/sse", async (req, res) => {
    console.log("New SSE Connection");

    // Create a unique session ID for this connection
    const sessionId = Math.random().toString(36).substring(7);

    // transport expects an endpoint where subsequent messages should be sent.
    // We append the sessionId so we can route the POST request back to this specific transport.
    const transport = new SSEServerTransport(`/message?sessionId=${sessionId}`, res);

    transports.set(sessionId, transport);

    transport.onclose = () => {
        console.log(`SSE Connection closed: ${sessionId}`);
        transports.delete(sessionId);
    };

    await server.connect(transport);
});

app.post("/message", async (req, res) => {
    const sessionId = req.query.sessionId as string;
    const transport = transports.get(sessionId);

    if (!transport) {
        console.log(`Session not found: ${sessionId}`);
        res.status(404).send("Session not found");
        return;
    }

    // Delegate the message handling to the transport
    await transport.handlePostMessage(req, res);
});

// Export app for Vercel
export default app;

// Only listen if running directly (not imported as a module)
// @ts-ignore
if (import.meta.url === `file://${process.argv[1]}`) {
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => {
        console.log(`MCP Server running on port ${PORT}`);
        console.log(`SSE Endpoint: http://localhost:${PORT}/sse`);
    });
}

